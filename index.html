<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Mini Galaga (Single, Joystick + HP + Round)</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      overflow: hidden;
      background: #070a12;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    #wrap {
      width: 100%; height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 10px;
      box-sizing: border-box;
      position: relative; /* âœ… ì˜¤ë²„ë ˆì´ ê¸°ì¤€ì  */
    }
    canvas {
      width: min(92vw, 520px);
      height: auto;
      aspect-ratio: 420 / 720;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: 0 12px 40px rgba(0,0,0,0.45);
      touch-action: none;
      background:
        radial-gradient(1200px 700px at 50% 20%, #121a33 0%, #070a12 60%, #05060b 100%);
    }

.scoreCard{
  margin-bottom: 30px;
  padding: 16px 26px;
  border-radius: 18px;
  border: 1px solid rgba(255,255,255,0.22);
  background:
    radial-gradient(140px 80px at 30% 20%, rgba(255,70,70,0.18), transparent 60%),
    linear-gradient(180deg, rgba(30,55,110,0.40), rgba(0,0,0,0.35));
  box-shadow:
    0 20px 60px rgba(0,0,0,0.55),
    inset 0 1px 0 rgba(255,255,255,0.10);
  text-align:center;
  line-height:1.0;
  backdrop-filter: blur(8px);
}

.scoreCard{
  color: rgba(255,80,80,0.95);
  font-weight: 900;
  font-size: 16px;
  letter-spacing: 2px;
}

.scoreCard .scoreNum{
  display:inline-block;
  margin-top: 8px;
  color:#fff;
  font-size: 44px;
  letter-spacing: 3px;
  text-shadow: 0 12px 24px rgba(0,0,0,0.75);
}

.goTitle{
  color:#fff;
  font-size:46px;
  font-weight:900;
  letter-spacing:2px;
  margin: 6px 0 18px;
  text-shadow: 0 14px 28px rgba(0,0,0,0.7);
}






    /* âœ… GAME OVER overlay (ë²„íŠ¼ í´ë¦­ë˜ë„ë¡) */
    #gameOverUI{
      position:absolute;
      inset: 0;
      margin: auto;
      width: min(92vw, 520px);
      aspect-ratio: 420 / 720;
      display:none;
      align-items:center;
      justify-content:center;
      flex-direction:column;
      background:rgba(0,0,0,0.55);
      border-radius:14px;
      pointer-events:auto;
    }
    #restartBtn{
      padding:12px 22px;
      font-size:18px;
      font-weight:800;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.3);
      background:rgba(40,100,200,0.6);
      color:#fff;
      cursor:pointer;
    }
    #restartBtn:active { transform: scale(0.98); }
  </style>
</head>
<body>


  <div id="wrap">
    <canvas id="c" width="420" height="720"></canvas>

    <!-- GAME OVER ë²„íŠ¼ -->
 <div id="gameOverUI">
  <!-- âœ… SCORE ì¹´ë“œ: GAME OVERë³´ë‹¤ ìœ„ -->
  <div id="finalScore" class="scoreCard">SCORE<br><span class="scoreNum">000000</span></div>

  <!-- GAME OVER -->
  <div class="goTitle">GAME OVER</div>

  <button id="restartBtn">ì¬ì‹œì‘</button>
</div>




  </div>







<script>






(() => {
  // âœ… ì¬ì‹œì‘ UI ì—˜ë¦¬ë¨¼íŠ¸ (IIFE ì•ˆìœ¼ë¡œ ì´ë™: ìŠ¤ì½”í”„ ë¬¸ì œ í•´ê²°)
  const gameOverUI = document.getElementById("gameOverUI");
  const restartBtn = document.getElementById("restartBtn");
  const finalScore = document.getElementById("finalScore");


  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  // --- Fixed internal resolution ---
  const W = canvas.width;
  const H = canvas.height;

  // --- Helpers ---
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand  = (a, b) => a + Math.random() * (b - a);

  function roundRectPath(x, y, w, h, r) {
    r = Math.max(0, Math.min(r, Math.min(w/2, h/2)));
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y,     x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x,     y + h, r);
    ctx.arcTo(x,     y + h, x,     y,     r);
    ctx.arcTo(x,     y,     x + w, y,     r);
    ctx.closePath();
  }
  function aabb(ax, ay, aw, ah, bx, by, bw, bh) {
    return (
      ax < bx + bw && ax + aw > bx &&
      ay < by + bh && ay + ah > by
    );
  }

  // =========================
  //   GAME STATE (GLOBAL)
  // =========================

// ğŸŒˆ ì˜ˆì˜ê³  ì•Œë¡ë‹¬ë¡í•œ í¸ëŒ€ ì»¬ëŸ¬ íŒ”ë ˆíŠ¸ (1~10í¸ëŒ€)
const FORMATION_COLORS = [
  { body:"#7AE7C7", wing:"rgba(122,231,199,0.55)", eye:"#0b1f1a" }, // 1 ë¯¼íŠ¸
  { body:"#8FD3FF", wing:"rgba(143,211,255,0.55)", eye:"#0b1a22" }, // 2 í•˜ëŠ˜
  { body:"#A3A1FF", wing:"rgba(163,161,255,0.55)", eye:"#16122b" }, // 3 ë¼ë²¤ë”
  { body:"#C9A7EB", wing:"rgba(201,167,235,0.55)", eye:"#201628" }, // 4 ì—°ë³´ë¼
  { body:"#FFB7D5", wing:"rgba(255,183,213,0.55)", eye:"#2b0f1c" }, // 5 í•‘í¬
  { body:"#FFC38A", wing:"rgba(255,195,138,0.55)", eye:"#2b1a0b" }, // 6 ì‚´êµ¬
  { body:"#FFE27A", wing:"rgba(255,226,122,0.55)", eye:"#2b250b" }, // 7 ì˜ë¡œìš°
  { body:"#B6E26D", wing:"rgba(182,226,109,0.55)", eye:"#1b2b0b" }, // 8 ë¼ì„
  { body:"#6EDB8F", wing:"rgba(110,219,143,0.55)", eye:"#0b2b16" }, // 9 ê·¸ë¦°
  { body:"#6FAAFF", wing:"rgba(111,170,255,0.55)", eye:"#0b1b2b" }, // 10 ë¸”ë£¨
];


  const HP_MAX = 100;
  const ROUND_MAX = 100; // âœ… Round: n/100

  let hp = HP_MAX;
  let hpDisplay = HP_MAX;
  let hpText = HP_MAX;

  let score = 0;
  
  let wave = 1; // âœ… Roundì™€ ë™ì¼í•˜ê²Œ ì‚¬ìš©

  let lives = 2; // âœ… ë‚¨ì€ ê¸°ì²´(ë¼ì´í”„) 2ê¸° í‘œì‹œ
  let respawnTimer = 0; // âœ… ê¸°ì²´ í„°ì¡Œì„ ë•Œ ì ê¹ ë¦¬ìŠ¤í° ë”œë ˆì´
  let roundIntro = 0;       // âœ… ë¼ìš´ë“œ ì‹œì‘ ì—°ì¶œ ë‚¨ì€ ì‹œê°„(ì´ˆ)
  let roundIntroShown = false; // âœ… ê°™ì€ ë¼ìš´ë“œì—ì„œ í­ì£½ 1íšŒë§Œ




  let paused = false;
  let gameOver = false;

  const player = {
    x: W / 2,
    y: H - 160,
    w: 26,
    h: 26,
    speed: 380,
    cooldown: 0,
    fireDelay: 1.0, // âœ… 1ì´ˆ ê°„ê²© ìë™ ë°œì‚¬
    invuln: 0
  };

  let bullets = [];
  let enemyBullets = [];
  let enemies = [];
  let particles = [];
  let scorePops = [];
  let stars = [];

  const formation = {
    x: 0,
    y: 85,
    dir: 1,
    speed: 55,
    drop: 18,
    wobble: 6
  };

  // =========================
  //        INPUT
  // =========================
  const keys = new Set();
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (k === " " || k === "spacebar") e.preventDefault();
    keys.add(k);

    // âœ… Rí‚¤ ì¬ì‹œì‘ì€ ì‚¬ìš© ì•ˆ í•¨ (ë²„íŠ¼ìœ¼ë¡œë§Œ)
    if (k === "p") paused = !paused;
  });
  window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

  // --- Virtual Joystick (bottom center) ---
  const joy = {
    cx: W / 2,
    cy: H - 70,
    baseR: 56,
    knobR: 24,
    active: false,
    pid: null,
    dx: 0,
    knobX: 0,
    knobY: 0
  };
  function resetJoy() {
    joy.dx = 0;
    joy.knobX = 0;
    joy.knobY = 0;
  }
  function getPointerPos(e) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: (e.clientX - rect.left) * (W / rect.width),
      y: (e.clientY - rect.top)  * (H / rect.height),
    };
  }
  function dist(x1,y1,x2,y2){ return Math.hypot(x1-x2, y1-y2); }

  function updateJoy(px, py) {
    const vx = px - joy.cx;
    const vy = py - joy.cy;
    const len = Math.hypot(vx, vy);
    const max = joy.baseR - joy.knobR;

    let nx = 0, ny = 0;
    if (len > 0.0001) {
      const scale = Math.min(1, max / len);
      nx = vx * scale;
      ny = vy * scale;
    }
    joy.knobX = nx;
    joy.knobY = ny;
    joy.dx = clamp(nx / max, -1, 1);
  }

  canvas.addEventListener("pointerdown", (e) => {
    // âœ… ê²Œì„ì˜¤ë²„ì¼ ë• ìº”ë²„ìŠ¤ ì…ë ¥ ë¬´ì‹œ(ë²„íŠ¼ë§Œ ëˆ„ë¥´ê²Œ)
    if (gameOver) return;

    canvas.setPointerCapture(e.pointerId);
    const p = getPointerPos(e);
    const d = dist(p.x, p.y, joy.cx, joy.cy);

    if (d <= joy.baseR + 10) {
      joy.active = true;
      joy.pid = e.pointerId;
      updateJoy(p.x, p.y);
    } else {
      // (ì„ íƒ) ìë™ë°œì‚¬ë¼ë„ íƒ­í•˜ë©´ ì¶”ê°€ ë°œì‚¬í•˜ê³  ì‹¶ìœ¼ë©´ shoot() ìœ ì§€
      // shoot();
    }
  });
  canvas.addEventListener("pointermove", (e) => {
    if (!joy.active || e.pointerId !== joy.pid) return;
    const p = getPointerPos(e);
    updateJoy(p.x, p.y);
  });
  canvas.addEventListener("pointerup", (e) => {
    if (joy.active && e.pointerId === joy.pid) {
      joy.active = false;
      joy.pid = null;
      resetJoy();
    }
  });
  canvas.addEventListener("pointercancel", () => { joy.active = false; joy.pid = null; resetJoy(); });

  // =========================
  //       GAME LOGIC
  // =========================

  function initStars() {
  stars = Array.from({ length: 90 }, () => ({
    x: Math.random() * W,
    y: Math.random() * H,
    r: rand(0.6, 1.8),
    s: rand(25, 90),
    col: `hsla(${Math.floor(rand(0, 360))}, 85%, 80%, ${rand(0.55, 0.95).toFixed(2)})`
  }));
}


function spawnWave(n) {
  bullets = [];
  enemyBullets = [];
  enemies = [];
  particles = [];
  scorePops = [];

  formation.x = 0;
  formation.y = 85;
  formation.dir = 1;
  formation.speed = 25;

  // âœ… ë¼ìš´ë“œ ìˆ˜ë§Œí¼ ì  ìƒì„± (ìµœëŒ€ 100ê¸°)
  const targetCount = Math.min(n, 100);

  const COLS = 10;      // í•œ ì¤„ ìµœëŒ€ 10ê¸°
  const gapX = 34;      // ê°€ë¡œ ê°„ê²©
  const gapY = 34;      // ì„¸ë¡œ ê°„ê²©
  const startY = 0;

  let created = 0;
  const rows = Math.ceil(targetCount / COLS);

  for (let r = 0; r < rows; r++) {
    const remaining = targetCount - created;
    const inRow = Math.min(COLS, remaining);

    // âœ… í•µì‹¬: ì´ë²ˆ ì¤„ì„ í•­ìƒ "í™”ë©´ ì •ì¤‘ì•™ ê¸°ì¤€"ìœ¼ë¡œ ë°°ì¹˜
    const rowWidth = (inRow - 1) * gapX;
    const rowStartX = W / 2 - rowWidth / 2;

    for (let i = 0; i < inRow; i++) {
      const type = (r === 0) ? "elite" : (r < 2 ? "fast" : "basic");
      const baseHp = (type === "elite") ? 2 : 1;
      const hpBoost = Math.floor((n - 1) / 4);
      const ehp = baseHp + hpBoost;

      enemies.push({
        
        x: rowStartX + i * gapX,
        y: startY + r * gapY,
        w: 24,
        h: 20,
        hp: ehp,
        maxHp: ehp,
        type,
        formationIdx: r,
        seed: Math.random() * 1000,
        shootCd: rand(0.7, 1.8) * Math.max(0.55, 1.05 - n * 0.05),
        alive: true
      });

      created++;
      if (created >= targetCount) break;
    }
  }
}



  function restart() {
    score = 0;
    wave = 1;
    respawnTimer = 0;

 
    lives = 2; // ì¬ì‹œì‘ ì‹œ ë‚¨ì€ ê¸°ì²´ 2ê¸°ë¡œ
   

    paused = false;
    gameOver = false;

    hp = HP_MAX;
    hpDisplay = hp;
    hpText = hp;

    player.x = W/2;
    player.cooldown = 0;
    player.invuln = 0;

  finalScore.innerHTML = `SCORE<br><span class="scoreNum">000000</span>`;


    // âœ… ì¬ì‹œì‘ ì‹œ ì˜¤ë²„ë ˆì´ ìˆ¨ê¹€
    gameOverUI.style.display = "none";

    spawnWave(wave);
    resetJoy();
  }

  // âœ… ì¬ì‹œì‘ ë²„íŠ¼ í´ë¦­ â†’ restart()
  restartBtn.addEventListener("click", () => {
    restart();
  });

  function nextWave() {
  // âœ… Round ìµœëŒ€ì¹˜ ì œí•œ
  wave = Math.min(ROUND_MAX, wave + 1);

  // âœ… ë‹¤ìŒ íŒ ì‹œì‘ ì‹œ HP ë§Œë•…ìœ¼ë¡œ íšŒë³µ
  hp = HP_MAX;
  hpDisplay = hp;
  hpText = hp;

  spawnWave(wave);


   roundIntro = 1.05;        // 1ì´ˆ ì •ë„ í‘œì‹œ
   roundIntroShown = false;

}


  function shoot() {
    if (paused || gameOver) return;
    if (player.cooldown > 0) return;

    player.cooldown = player.fireDelay;
    bullets.push({
      x: player.x,
      y: player.y - 18,
      vx: 0,
      vy: -600,
      r: 3
    });
  }

  function explode(x, y, n=18) {
    for (let i=0; i<n; i++) {
      const a = Math.random() * Math.PI * 2;
      const sp = rand(60, 240);
      particles.push({
        x, y,
        vx: Math.cos(a) * sp,
        vy: Math.sin(a) * sp,
        life: rand(0.25, 0.65),
        r: rand(1, 2.4)
      });
    }
  }


function roundBurst(x, y, n=70) {
  // âœ… Round ì‹œì‘ ì „ìš© íŒŒí‹°í´(ì¢€ ë” í™”ë ¤í•˜ê²Œ)
  for (let i=0; i<n; i++) {
    const a = Math.random() * Math.PI * 2;
    const sp = rand(120, 420);
    particles.push({
      x, y,
      vx: Math.cos(a) * sp,
      vy: Math.sin(a) * sp,
      life: rand(0.35, 0.95),
      r: rand(1.4, 3.2),
      // ìƒ‰ì„ ë‹¤ì–‘í•˜ê²Œ(ì•Œë¡ë‹¬ë¡)
      col: `hsla(${Math.floor(rand(0,360))}, 95%, 70%, 0.95)`
    });
  }
}




  function popScore(x, y, txt) {
    scorePops.push({ x, y, vy: -28, life: 0.75, txt });
  }

 function damagePlayer(dmg) {
  // âœ… ë¦¬ìŠ¤í° ì¤‘(ë¬´ì )ì—ëŠ” ë°ë¯¸ì§€ ë¬´ì‹œ
  if (player.invuln > 0 || respawnTimer > 0 || gameOver) return;

  hp -= dmg;
  hp = Math.max(0, hp);
  hpText = hp;

  // ë§ì•˜ì„ ë•Œ ì ê¹ ë¬´ì 
  player.invuln = 0.9;
  explode(player.x, player.y, 22);

  // âœ… HPê°€ 0ì´ë©´ "ê¸°ì²´ íŒŒê´´" ì²˜ë¦¬
  if (hp <= 0) {
    // ë‚¨ì€ ê¸°ì²´(lives)ëŠ” 'ì˜ˆë¹„ ê¸°ì²´'ë¼ê³  ê°€ì • (í˜„ì¬ ê¸°ì²´ ì œì™¸)
    if (lives > 0) {
      lives -= 1;

      // ë¦¬ìŠ¤í° ì—°ì¶œ/ì•ˆì „ì¥ì¹˜
      respawnTimer = 2.0;          // 
      player.invuln = 1.6;         // ë¶€í™œ í›„ ì ê¹ ë” ë¬´ì 
      bullets = [];                // ë‚´ íƒ„ì€ ì·¨í–¥(ì›í•˜ë©´ ìœ ì§€ ê°€ëŠ¥)
      enemyBullets = [];           // âœ… ì¦‰ì‚¬ ë°©ì§€ìš©ìœ¼ë¡œ ì íƒ„ì€ ë¹„ìš°ëŠ” ê±¸ ì¶”ì²œ
      explode(player.x, player.y, 30);

      // ì¦‰ì‹œ ìœ„ì¹˜ ë¦¬ì…‹(ë‹¤ìŒ ê¸°ì²´ê°€ ë“±ì¥í•œ ëŠë‚Œ)
      player.x = W / 2;
      // hpëŠ” ë¦¬ìŠ¤í° íƒ€ì´ë¨¸ ëë‚  ë•Œ íšŒë³µ
    } else {
      // âœ… ì˜ˆë¹„ ê¸°ì²´ë„ ì—†ìœ¼ë©´ ê²Œì„ì˜¤ë²„
      gameOver = true;
      finalScore.innerHTML = `SCORE<br><span class="scoreNum">${String(score).padStart(6,"0")}</span>`;

      gameOverUI.style.display = "flex";
    }
  }
}


  // =========================
  //     UPDATE / RENDER
  // =========================
  let last = performance.now();

  function update(dt, t) {


if (roundIntro > 0) roundIntro = Math.max(0, roundIntro - dt);





// âœ… ë¦¬ìŠ¤í° íƒ€ì´ë¨¸ ì²˜ë¦¬: ëë‚˜ë©´ HP íšŒë³µ + ì  í¸ëŒ€ "ì´ˆê¸° ì¶œë°œì "ìœ¼ë¡œ ë¦¬ì…‹
if (respawnTimer > 0) {
  respawnTimer = Math.max(0, respawnTimer - dt);

  // ë¦¬ìŠ¤í° ëŒ€ê¸° ì¤‘ì—ëŠ” ì /íƒ„ ì›€ì§ì„ì„ ë©ˆì¶”ê³ (ìŠ¤íƒ€ëŠ” ê³„ì†) ì‹¶ìœ¼ë©´ ì•„ë˜ returnê³¼ ê°™ì´ ì”€
  // (returnì€ ì•„ë˜ 3ë²ˆì—ì„œ ì²˜ë¦¬)

  if (respawnTimer === 0) {
    // í”Œë ˆì´ì–´ ë¶€í™œ
    hp = HP_MAX;
    hpDisplay = hp;
    hpText = hp;

    player.x = W / 2;
    player.cooldown = 0;
    player.invuln = 1.6; // ë¶€í™œ í›„ ì ê¹ ë¬´ì 

    // âœ… ì ê¸°ë“¤ì€ "ë‚¨ì€ ê²ƒ ê·¸ëŒ€ë¡œ" ë‘ê³ , í¸ëŒ€ ìœ„ì¹˜ë§Œ ì´ˆê¸° ì¶œë°œì ìœ¼ë¡œ
    formation.x = 0;
    formation.y = 85;
    formation.dir = 1;

    // âœ… íƒ„/íŒŒí‹°í´ ì •ë¦¬(ì¬ê°œí•  ë•Œ í™”ë©´ ê¹”ë”í•˜ê²Œ)
    bullets = [];
    enemyBullets = [];
    particles = [];
    scorePops = [];
  }
}





    if (gameOver) return;

    for (const s of stars) {
      s.y += s.s * dt;
      if (s.y > H + 10) {
        s.y = -10;
        s.x = Math.random() * W;
        s.s = rand(25, 90);
        s.r = rand(0.6, 1.8);
        s.col = `hsla(${Math.floor(rand(0, 360))}, 85%, 80%, ${rand(0.55, 0.95).toFixed(2)})`;
      }
    }


   if (respawnTimer > 0) return; 

    let move = 0;
    if (keys.has("arrowleft") || keys.has("a")) move -= 1;
    if (keys.has("arrowright") || keys.has("d")) move += 1;
    if (Math.abs(joy.dx) > 0.02) move += joy.dx;

    player.x += move * player.speed * dt;
    player.x = clamp(player.x, 18, W - 18);

    // ì¿¨ë‹¤ìš´ ê°ì†Œ
    player.cooldown = Math.max(0, player.cooldown - dt);

    // âœ… ìë™ë¯¸ì‚¬ì¼ë°œì‚¬: 2ì´ˆ ê°„ê²©ìœ¼ë¡œ 1ë°œ
    if (!paused && !gameOver && player.cooldown <= 0) {
      shoot();
    }

    player.invuln = Math.max(0, player.invuln - dt);

    formation.x += formation.dir * formation.speed * dt;

    let minX = Infinity, maxX = -Infinity;

    for (const e of enemies) {
      if (!e.alive) continue;
      minX = Math.min(minX, e.x + formation.x);
      maxX = Math.max(maxX, e.x + formation.x);
    }
    if (minX !== Infinity) {
      if (minX < 30 && formation.dir < 0) { formation.dir = 1; formation.y += formation.drop; }
      if (maxX > W - 30 && formation.dir > 0) { formation.dir = -1; formation.y += formation.drop; }
    }

    const aliveEnemies = enemies.filter(e => e.alive);
    for (const e of aliveEnemies) {
      e.shootCd -= dt;
      if (e.shootCd <= 0) {
        e.shootCd = rand(0.9, 2.2) * Math.max(0.50, 1.05 - wave*0.045);

        const chance = e.type === "elite" ? 0.55 : (e.type === "fast" ? 0.40 : 0.28);
        if (Math.random() < chance) {
          const ex = e.x + formation.x;
          const ey = e.y + formation.y + Math.sin((t + e.seed) * 3) * 2;
          const dx = (player.x - ex) * 0.12;

          enemyBullets.push({
            x: ex,
            y: ey + 10,
            vx: clamp(dx, -160, 160),
            vy: 320,
            r: 3
          });
        }
      }
    }

    for (const b of bullets) { b.x += b.vx * dt; b.y += b.vy * dt; }
    bullets = bullets.filter(b => b.y > -60);

    for (const b of enemyBullets) { b.x += b.vx * dt; b.y += b.vy * dt; }
    enemyBullets = enemyBullets.filter(b => b.y < H + 80);

    for (const p of particles) {
      p.life -= dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= (1 - 2.2 * dt);
      p.vy *= (1 - 2.2 * dt);
    }
    particles = particles.filter(p => p.life > 0);

    for (const s of scorePops) {
      s.life -= dt;
      s.y += s.vy * dt;
    }
    scorePops = scorePops.filter(s => s.life > 0);

    for (const b of bullets) {
      if (b.y < -10) continue;

      for (const e of enemies) {
        if (!e.alive) continue;

        const ex = e.x + formation.x;
        const ey = e.y + formation.y + Math.sin((t + e.seed) * 2.8) * formation.wobble;

        const bw = b.r * 2, bh = 14;
        const bx = b.x - b.r, by = b.y - 10;

        const ex0 = ex - e.w/2, ey0 = ey - e.h/2;

        if (aabb(bx, by, bw, bh, ex0, ey0, e.w, e.h)) {
          b.y = -9999;

          e.hp -= 1;
          explode(ex, ey, 10);

     if (e.hp <= 0) {
  e.alive = false;

  const add = 10;            // âœ… ì  1ëŒ€ íŒŒê´´ = 10ì  ê³ ì •
  score += add;
  popScore(ex, ey, `+${add}`);

  explode(ex, ey, 20);
}




          break;
        }
      }
    }
    bullets = bullets.filter(b => b.y > -500);

    if (player.invuln <= 0) {
      const px0 = player.x - player.w/2;
      const py0 = player.y - player.h/2;

      for (const b of enemyBullets) {
        const bx0 = b.x - b.r;
        const by0 = b.y - b.r;
        if (aabb(bx0, by0, b.r*2, b.r*2, px0, py0, player.w, player.h)) {
          b.y = 99999;
          damagePlayer(18);
          break;
        }
      }
      enemyBullets = enemyBullets.filter(b => b.y < 9999);
    }



  for (const e of enemies) {
  if (!e.alive) continue;

  // ì ê¸° ì‹¤ì œ í™”ë©´ y (wobble í¬í•¨í•˜ë©´ ë” ìì—°ìŠ¤ëŸ¬ì›€)
  const ey = e.y + formation.y; 
  const enemyBottom = ey + e.h / 2;

  // âœ… "í”Œë ˆì´ì–´ ë°”ë¡œ ìœ— ë¼ì¸" = í”Œë ˆì´ì–´ì˜ y - (í”Œë ˆì´ì–´ ë†’ì´/2) ê·¼ì²˜
  const playerLine = player.y - player.h / 2;

  // ì ì´ í”Œë ˆì´ì–´ ë¼ì¸ì— ë‹¿ìœ¼ë©´ ë¬´ì¡°ê±´ ê¸°ì²´ íŒŒê´´(HP ë¬´ì‹œ)
  if (enemyBottom >= playerLine) {
    // HPê°€ ì–¼ë§ˆë“  ì¦‰ì‚¬ì‹œí‚¤ê¸° ìœ„í•´ í° ë°ë¯¸ì§€ë¥¼ ì¤Œ
    damagePlayer(HP_MAX + 9999);

    // (ì„ íƒ) í¸ëŒ€ ì‚´ì§ ìœ„ë¡œ ë°€ì–´ì˜¬ë ¤ì„œ ì—°ì† íŒì • ë°©ì§€
    formation.y -= 28;

    break;
  }
}



    if (enemies.every(e => !e.alive)) {
      nextWave();
    }
  }

  function render(t) {
    ctx.clearRect(0, 0, W, H);

    ctx.save();
    ctx.globalAlpha = 0.9;
    for (const s of stars) {
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
      ctx.fillStyle = s.col;

      ctx.fill();
    }
    ctx.restore();

    drawPlayer(t);

    for (const e of enemies) {
      if (!e.alive) continue;
      const ex = e.x + formation.x;
      const ey = e.y + formation.y + Math.sin((t + e.seed) * 2.8) * formation.wobble;


  


     drawEnemy(ex, ey, e.hp, e.maxHp, e.formationIdx);

    }

    ctx.save();
    ctx.fillStyle = "#c6ff65";
    for (const b of bullets) {
      roundRectPath(b.x - 2, b.y - 9, 4, 16, 3);
      ctx.fill();
    }


ctx.fillStyle = "#ff6d8c";
for (const b of enemyBullets) {

  // âœ… ì¡°ì´ìŠ¤í‹± ì˜ì—­ ì•ˆì— ë“¤ì–´ì˜¨ ì íƒ„ì€ ê·¸ë¦¬ì§€ ì•ŠìŒ
  const dx = b.x - joy.cx;
  const dy = b.y - joy.cy;
  const dist = Math.hypot(dx, dy);

  if (dist < joy.baseR + 6) {
    continue; // ì¡°ì´ìŠ¤í‹± "ì•„ë˜ë¡œ ì§€ë‚˜ê°€ê²Œ" ì²˜ë¦¬
  }

  roundRectPath(b.x - 2, b.y - 7, 4, 12, 3);
  ctx.fill();
}



    ctx.restore();

    ctx.save();
    for (const p of particles) {
      const a = clamp(p.life / 0.65, 0, 1);
      ctx.globalAlpha = a;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fillStyle = p.col || "rgba(255,220,140,0.95)";

      ctx.fill();
    }
    ctx.restore();

    drawScorePops();
    drawHPBar();
   
   drawScoreUI();


    drawWaveBadge();   // âœ… ì—¬ê¸°!
    

    drawJoystick();
    drawLivesUI();

    drawRoundIntro(t);

   
    // âœ… ì¼ì‹œì •ì§€ ì•ˆë‚´
    if (paused) overlayText("ì¼ì‹œì •ì§€ (P)", "ì¡°ì´ìŠ¤í‹±=ì´ë™ / ìë™ë°œì‚¬");
    
  }


function drawRoundIntro(t) {
  if (roundIntro <= 0) return;

  // í­ì£½ì€ ì²˜ìŒ 1ë²ˆë§Œ
  if (!roundIntroShown) {
    roundIntroShown = true;
    roundBurst(W/2, H/2 - 20, 90);
  }

  // ì‹œê°„ ê°ì†Œ (renderì—ëŠ” dtê°€ ì—†ìœ¼ë‹ˆ, updateì—ì„œ ì¤„ì´ëŠ” ê²Œ ì •ì„)
  // -> ê·¸ë˜ì„œ updateì— 2ì¤„ë§Œ ì¶”ê°€í• ê²Œìš” (ì•„ë˜ 4-3)
  const a = clamp(roundIntro / 1.05, 0, 1);

  // íŒ¡ ëŠë‚Œ(ìŠ¤ì¼€ì¼ ì—… + í˜ì´ë“œ)
  const pop = 1 + (1 - a) * 0.18;

  ctx.save();
  ctx.translate(W/2, H/2 - 20);
  ctx.scale(pop, pop);
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";

  const txt = `Round ${wave}`;

  // ë’¤ ê·¸ë¦¼ì/ì™¸ê³½
  ctx.font = "900 44px 'Impact','Arial Black','Trebuchet MS',system-ui,sans-serif";
  ctx.lineJoin = "round";
  ctx.lineWidth = 10;
  ctx.globalAlpha = 0.55 * a;
  ctx.strokeStyle = "rgba(0,0,0,0.85)";
  ctx.strokeText(txt, 0, 0);

  // ë³¸ë¬¸(ê·¸ë¼ë°ì´ì…˜)
  const grad = ctx.createLinearGradient(-120, -20, 120, 20);
  grad.addColorStop(0, "#FFE27A");
  grad.addColorStop(0.5, "#FFB7D5");
  grad.addColorStop(1, "#8FD3FF");
  ctx.globalAlpha = 0.95 * a;
  ctx.fillStyle = grad;
  ctx.fillText(txt, 0, 0);

  // ë°˜ì§ í•˜ì´ë¼ì´íŠ¸
  ctx.globalAlpha = 0.35 * a;
  ctx.lineWidth = 3;
  ctx.strokeStyle = "rgba(255,255,255,0.8)";
  ctx.strokeText(txt, 1, -1);

  ctx.restore();
}




  function drawHPBar() {
    const pad = 12;
    const x = pad;
    const y = pad;

    const barW = 190;
    const barH = 14;
    const radius = 8;

    hpDisplay += (hp - hpDisplay) * 0.18;
    if (Math.abs(hp - hpDisplay) < 0.05) hpDisplay = hp;

    const pct = clamp(hpDisplay / HP_MAX, 0, 1);

    ctx.save();

    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(255,255,255,0.35)";
    ctx.fillStyle = "rgba(0,0,0,0.45)";
    roundRectPath(x - 2, y - 2, barW + 4, barH + 4, radius + 2);
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = "rgba(20,20,30,0.85)";
    roundRectPath(x, y, barW, barH, radius);
    ctx.fill();

    const grad = ctx.createLinearGradient(x, y, x, y + barH);
    grad.addColorStop(0, "#ff8fa3");
    grad.addColorStop(1, "#ff2e55");
    ctx.fillStyle = grad;
    roundRectPath(x, y, barW * pct, barH, radius);
    ctx.fill();

    ctx.globalAlpha = 0.30;
    ctx.fillStyle = "#ffffff";
    roundRectPath(x + 2, y + 2, Math.max(0, barW * pct - 4), 3, 3);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.strokeStyle = "rgba(0,0,0,0.35)";
    ctx.lineWidth = 1;
    roundRectPath(x, y, barW, barH, radius);
    ctx.stroke();

    const hpNow = Math.max(0, Math.floor(hpText));
    const hpMax = HP_MAX;

    ctx.font = "800 11px 'Segoe UI', system-ui, sans-serif";
    ctx.textBaseline = "middle";
    ctx.textAlign = "left";

    ctx.fillStyle = "rgba(0,0,0,0.70)";
    ctx.fillText("HP:", x + 8 + 1, y + barH/2 + 1);
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    ctx.fillText("HP:", x + 8, y + barH/2);

    ctx.textAlign = "center";
    ctx.fillStyle = "rgba(0,0,0,0.70)";
    ctx.fillText(`${hpNow} / ${hpMax}`, x + barW/2 + 1, y + barH/2 + 1);
    ctx.fillStyle = "#ffffff";
    ctx.fillText(`${hpNow} / ${hpMax}`, x + barW/2, y + barH/2);

    ctx.restore();
  }

 

function drawWaveBadge() {
  // âœ… "Round n" (ë…¸ë‘/ì˜¤ë Œì§€ + ì™¸ê³½ì„ ) + ìˆ«ìë§Œ ì—°í•œ ë¹¨ê°•
  const x = 16;
  const y = H - 22;

  const label = "Round ";
  const numStr = String(wave);

  ctx.save();

  // âœ… ê¸€ì”¨ ìŠ¤íƒ€ì¼: ê¸°ìš¸ì„ ì œê±°(ë˜‘ë°”ë¡œ)
  ctx.font = "900 26px 'Impact','Arial Black','Trebuchet MS',system-ui,sans-serif";
  ctx.textAlign = "left";
  ctx.textBaseline = "middle";

  // Round í…ìŠ¤íŠ¸ ê·¸ë¼ë°ì´ì…˜(ë…¸ë‘â†’ì˜¤ë Œì§€)
  const grad = ctx.createLinearGradient(x, y - 18, x + 160, y + 10);
  grad.addColorStop(0, "#FFE27A");
  grad.addColorStop(0.45, "#FFC247");
  grad.addColorStop(1, "#FF7A00");

  // ê³µí†µ ê·¸ë¦¼ì
  ctx.shadowColor = "rgba(0,0,0,0.55)";
  ctx.shadowBlur = 10;
  ctx.shadowOffsetY = 2;

  // ===== 1) "Round " ë¶€ë¶„ =====
  ctx.lineJoin = "round";
  ctx.lineWidth = 6;
  ctx.strokeStyle = "rgba(0,0,0,0.70)";
  ctx.strokeText(label, x, y);

  ctx.fillStyle = grad;
  ctx.fillText(label, x, y);

  // í•˜ì´ë¼ì´íŠ¸
  ctx.shadowBlur = 0;
  ctx.globalAlpha = 0.35;
  ctx.lineWidth = 2;
  ctx.strokeStyle = "rgba(255,255,255,0.65)";
  ctx.strokeText(label, x + 1, y - 1);
  ctx.globalAlpha = 1;

  // ===== 2) ìˆ«ì ë¶€ë¶„(ì—°í•œ ë¹¨ê°•) =====
  const labelW = ctx.measureText(label).width;
  const nx = x + labelW;

  // ìˆ«ìì—ë„ ê·¸ë¦¼ì ë‹¤ì‹œ ì ìš©
  ctx.shadowColor = "rgba(0,0,0,0.55)";
  ctx.shadowBlur = 10;
  ctx.shadowOffsetY = 2;

  // ìˆ«ì ì™¸ê³½ì„ 
  ctx.lineJoin = "round";
  ctx.lineWidth = 6;
  ctx.strokeStyle = "rgba(0,0,0,0.70)";
  ctx.strokeText(numStr, nx, y);

  // ìˆ«ì ì±„ì›€(ì—°í•œ ë¹¨ê°•)
  ctx.fillStyle = "#ff9aa8";
  ctx.fillText(numStr, nx, y);

  // ìˆ«ì í•˜ì´ë¼ì´íŠ¸
  ctx.shadowBlur = 0;
  ctx.globalAlpha = 0.35;
  ctx.lineWidth = 2;
  ctx.strokeStyle = "rgba(255,255,255,0.65)";
  ctx.strokeText(numStr, nx + 1, y - 1);
  ctx.globalAlpha = 1;

  ctx.restore();
}


  function drawScorePops() {
    ctx.save();
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    for (const s of scorePops) {
      const a = clamp(s.life / 0.75, 0, 1);
      ctx.globalAlpha = a;
      ctx.font = "800 18px 'Trebuchet MS','Segoe UI',system-ui,sans-serif";
      ctx.shadowColor = "rgba(255,190,120,0.65)";
      ctx.shadowBlur = 10;
      ctx.fillStyle = "#ffd39b";
      ctx.fillText(s.txt, s.x, s.y);
      ctx.shadowBlur = 0;
    }
    ctx.restore();
  }







function drawLivesUI() {
  // ëª©í‘œ ìœ„ì¹˜: "ì¡°ì´ìŠ¤í‹± ì¤‘ì‹¬"ê³¼ "í™”ë©´ ì˜¤ë¥¸ìª½ í•˜ë‹¨"ì˜ ì¤‘ì•™(ì¤‘ê°„ ì§€ì )
  const margin = 18;
  const cornerX = W - margin;
  const cornerY = H - margin;

  const centerX = (joy.cx + cornerX) / 2;
  const centerY = (joy.cy + cornerY) / 2;

  // í”Œë ˆì´ ê¸°ì²´ì™€ ê°™ì€ í¬ê¸°
  const s = 1.0;

  // ê¸°ì²´ ê°„ê²© (í”Œë ˆì´ ê¸°ì²´ í¬ê¸° ê¸°ì¤€)
  const gap = 32;

  // ì•„ì´ì½˜ ì „ì²´ í­ ê³„ì‚°í•´ì„œ "ê°€ìš´ë° ì •ë ¬"
  const shipW = 24 * s; // drawLifeShipì´ ëŒ€ëµ ì¢Œìš° 12 ê¸°ì¤€ì´ë¼ í­ 24
  const totalW = (lives <= 0) ? 0 : (shipW + (lives - 1) * gap);

  const startX = W - margin - totalW;
  const y = H - margin - 14; // ì‚´ì§ ìœ„ë¡œ ë„ì›€ (ë°”ë‹¥ ë°€ì°© ë°©ì§€)

 

  ctx.save();
  ctx.globalAlpha = 0.95;

  for (let i = 0; i < lives; i++) {
    drawLifeShip(startX + i * gap, y, s);
  }

  ctx.restore();
}


function drawLifeShip(x, y, s=1) {
  // ì‘ì€ í”Œë ˆì´ì–´ ê¸°ì²´ ëŠë‚Œ(ì‚¼ê°í˜• + ì•½ê°„ì˜ ê¸€ë¡œìš°)
  ctx.save();
  ctx.translate(x, y);
  ctx.scale(s, s);

  // ê¸€ë¡œìš°
  ctx.globalAlpha = 0.25;
  ctx.beginPath();
  ctx.arc(0, 4, 18, 0, Math.PI * 2);
  ctx.fillStyle = "rgba(110,180,255,0.35)";
  ctx.fill();

  // ë³¸ì²´
  ctx.globalAlpha = 1;
  ctx.beginPath();
  ctx.moveTo(0, -14);
  ctx.lineTo(12, 10);
  ctx.lineTo(0, 6);
  ctx.lineTo(-12, 10);
  ctx.closePath();
  ctx.fillStyle = "#eaf1ff";
  ctx.fill();

  // ì½•í•
  roundRectPath(-4, -4, 8, 8, 3);
  ctx.fillStyle = "#5fb0ff";
  ctx.fill();

  // ì™¸ê³½ì„ (ì‚´ì§)
  ctx.lineWidth = 2;
  ctx.strokeStyle = "rgba(0,0,0,0.35)";
  ctx.stroke();

  ctx.restore();
}










  function drawJoystick() {
    ctx.save();
    const alpha = joy.active ? 0.95 : 0.55;
    ctx.globalAlpha = alpha;

    ctx.beginPath();
    ctx.arc(joy.cx, joy.cy, joy.baseR, 0, Math.PI*2);
    ctx.fillStyle = "rgba(0,0,0,0.26)";
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(140,190,255,0.35)";
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(joy.cx, joy.cy, joy.baseR - 12, 0, Math.PI*2);
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.stroke();

    ctx.globalAlpha = alpha * 0.8;
    ctx.fillStyle = "rgba(210,235,255,0.65)";
    drawTri(joy.cx - 22, joy.cy, -1);
    drawTri(joy.cx + 22, joy.cy,  1);

    ctx.globalAlpha = alpha;
    const kx = joy.cx + joy.knobX;
    const ky = joy.cy + joy.knobY;

    ctx.beginPath();
    ctx.arc(kx, ky, joy.knobR, 0, Math.PI*2);
    ctx.fillStyle = "rgba(40,90,150,0.55)";
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(180,230,255,0.50)";
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(kx - 7, ky - 7, 5, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,255,255,0.25)";
    ctx.fill();

    ctx.restore();
  }

  function drawTri(x, y, dir) {
    ctx.beginPath();
    if (dir < 0) {
      ctx.moveTo(x + 6, y - 10);
      ctx.lineTo(x - 6, y);
      ctx.lineTo(x + 6, y + 10);
    } else {
      ctx.moveTo(x - 6, y - 10);
      ctx.lineTo(x + 6, y);
      ctx.lineTo(x - 6, y + 10);
    }
    ctx.closePath();
    ctx.fill();
  }


function drawScoreUI() {
  const pad = 12;
  const hpBarW = 190;
  const x = pad + hpBarW + 14;
  const y = pad + 1;

  const title = "SCORE";
  const value = String(score).padStart(6, "0");

  ctx.save();
  ctx.textAlign = "left";
  ctx.textBaseline = "top";

  ctx.font = "900 20px 'Trebuchet MS', system-ui, sans-serif";
  ctx.fillStyle = "#ff3b3b";
  ctx.shadowColor = "rgba(0,0,0,0.65)";
  ctx.shadowBlur = 6;
  ctx.fillText(title, x, y);

  ctx.shadowBlur = 0;
  ctx.font = "900 20px 'Trebuchet MS', system-ui, sans-serif";
  ctx.fillStyle = "#ffffff";
  ctx.fillText(value, x, y + 20);

  ctx.restore();
}


  function drawPlayer(t) {
    const blink = player.invuln > 0 ? (Math.sin(t * 18) > 0 ? 0.35 : 1) : 1;

    ctx.save();
    ctx.globalAlpha = blink;
    ctx.translate(player.x, player.y);

    ctx.beginPath();
    ctx.arc(0, 4, 22, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(110,180,255,0.15)";
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(0, -16);
    ctx.lineTo(16, 12);
    ctx.lineTo(0, 8);
    ctx.lineTo(-16, 12);
    ctx.closePath();
    ctx.fillStyle = "#eaf1ff";
    ctx.fill();

    roundRectPath(-5, -6, 10, 10, 4);
    ctx.fillStyle = "#5fb0ff";
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(-9, 12);
    ctx.lineTo(-4, 22 + Math.sin(t * 20) * 2);
    ctx.lineTo(0, 12);
    ctx.closePath();
    ctx.fillStyle = "rgba(255,180,80,0.95)";
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(9, 12);
    ctx.lineTo(4, 22 + Math.cos(t * 18) * 2);
    ctx.lineTo(0, 12);
    ctx.closePath();
    ctx.fillStyle = "rgba(255,120,90,0.9)";
    ctx.fill();

    ctx.restore();
  }

function drawEnemy(x, y, hpVal, maxHp, formationIdx = 0)
 {
  ctx.save();
  ctx.translate(x, y);

  // âœ… í¸ëŒ€(ì¤„) ìƒ‰ ìš°ì„  ì ìš©: 0~9 â†’ íŒ”ë ˆíŠ¸
  const idx = clamp(formationIdx, 0, 9);
  const pal = FORMATION_COLORS[idx];

  let body = pal.body;
  let wing = pal.wing;
  let eye  = pal.eye;

  // ë‚ ê°œ
  ctx.beginPath();
  ctx.ellipse(-14, 0, 12, 7, -0.25, 0, Math.PI*2);
  ctx.ellipse(14, 0, 12, 7,  0.25, 0, Math.PI*2);
  ctx.fillStyle = wing;
  ctx.fill();

  // ëª¸í†µ
  roundRectPath(-12, -9, 24, 18, 7);
  ctx.fillStyle = body;
  ctx.fill();

  // ëˆˆ
  ctx.beginPath();
  ctx.arc(-5, -1, 2.2, 0, Math.PI*2);
  ctx.arc( 5, -1, 2.2, 0, Math.PI*2);
  ctx.fillStyle = eye;
  ctx.fill();

  // âœ… ì‘ì€ HPë°” (ë¨¸ë¦¬ ìœ„)
const barW = 16;
const barH = 3;
const yOff = -16; // ë¨¸ë¦¬ ìœ„ ìœ„ì¹˜

const ratio = Math.max(0, Math.min(1, hpVal / Math.max(1, maxHp)));

ctx.fillStyle = "rgba(0,0,0,0.55)";
ctx.fillRect(-barW/2, yOff, barW, barH);

ctx.fillStyle = "#ff9aa8";
ctx.fillRect(-barW/2, yOff, barW * ratio, barH);


  ctx.restore();
}






  function overlayText(title, sub) {
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = "#ffffff";
    ctx.textAlign = "center";
    ctx.font = "bold 34px system-ui, sans-serif";
    ctx.fillText(title, W/2, H/2 - 10);

    if (sub) {
      ctx.fillStyle = "rgba(230,240,255,0.9)";
      ctx.font = "14px system-ui, sans-serif";
      ctx.fillText(sub, W/2, H/2 + 24);
    }

    ctx.restore();
  }

  function loop(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    if (!paused) update(dt, now/1000);
    render(now/1000);

    requestAnimationFrame(loop);
  }

  function boot() {
    initStars();
    restart();
    requestAnimationFrame(loop);
  }

  boot();
})();
</script>
</body>
</html>
